package Note0517;
/*
    关于java中的整数型

 */
public class DataTypeTest05 {
    public static void main(String[] args) {
        long x=100L;
        //编译报错，大容量不能直接赋值给小容量
        //int y=x;

        //大容量转换成小容量，需要进行强制类型转换需要加“强制类型转换符”
        //编译通过了，但是运行阶段可能损失精度。
        //墙砖原理：
            //原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
            //强转之后的数据：00000000 00000000 00000000 01100100（计算机底层补码）
            //将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】
        int y=(int)x;
        System.out.println(y);

        long k=2147483648L;
        int e=(int)k;
        System.out.println(e);//损失精度严重，结果是负数-2147483648

        //分析以下程序是否可以编译通过？
        //依据目前所学的内容，以下程序是无法编译通过的
        //错误理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte
        //但是，在实际编译的时候以下代码编译通过了，这说明：在java语言当中，当一个数字型字面值
        //没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量。
        byte b=50;
        byte c=127;
        //编译错误，128int字面值超出了byte的范围
        //byte b1=128;
        byte b1=(byte)128;
        System.out.println(b1);//-128

        /*
        原始数据：00000000 00000000 00000000 11000110
        强制类型转换之后：11000110
        11000110现在在计算机当中存储，它是一个补码，将补码转换成原码就是该数字：
        11000110-1-->11000101
        00111010--->58
        //-58
         */
        byte m=(byte)198;
        System.out.println(m);//-58

        short s=32767;
        //short s1=32768;

        char cc=65535;
        //cc=65536;
        System.out.println(cc);//￿

        /*
            当一个整数字面值没有超出byte,short,char的取值范围，这个字面值
            可以直接赋值给byte，short，char类型的变量。这种机制SUN允许了，目的
            是为了方便程序员的编程。
         */
    }
}
/*
    计算机二进制有三种表示形式：原码 反码 补码
    计算机在任何情况下底层表示和存储数据的时候采用了补码形式。
 */